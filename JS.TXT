----------------------------------------------------------------------------------------------------
const a = [0,1,2]
const a = Array.of(0,1,2)
const a = Array.from([0,1,2])
const a = Array.from(Array(3), (x,i,a) => i)
const a = Array(3).fill().map((x,i,a) => i)
const a = Array.from('012', x => +x)

a.every(Boolean) ? true : false
a.some(Boolean) ? true : false

const b = a.filter(Boolean)
const b = a.map(x => x)
const acc = a.reduce((acc,x) => acc + x, 0)

console.assert(a === a.sort((lhs, rhs) => lhs - rhs))
a.forEach((x,i,a) => console.log(x,i))

console.assert(eq([1,2], [0,1,2].map(x => x ? [x] : []).flat()))
console.assert(eq([1,2], [0,1,2].flatMap(x => x ? [x] : [])))
console.assert(eq([1,2], [0,1,2].map(x => x ? x : undefined).filter(x => x !== undefined)))

const b = a.slice()
console.assert(b !== a.slice())
console.assert(eq(b, a.slice()))

const b = a.slice(i1,i2)    // zero based i
const b = a.slice(-i1,-i2)  // zerp based (n - i)

const d = a.splice(i,n, e1,e2,...eM)   // zero based i
const d = a.splice(i,n, e1,e2,...eM)   // zero based (n - i)

console.assert(s === s.split(d).join(d))

----------------------------------------------------------------------------------------------------
console.assert(3, Function.apply.bind(Math.max, null)([1,2,3]))
console.assert(3, Function.call.bind(Math.max, null)(1,2,3))

Function.call.bind(Array.prototype.map)([1,2,3], x => x + x)

const ap = f => (g => (...ys) => x => g(x, ys))(Function.apply.bind(f))
map = ap(Array.prototype.map)
map(x => x + x)([1,2,3])

----------------------------------------------------------------------------------------------------
const eq = (x, y) => {
  if (x === y) { return true }
  if (x instanceof Function || y instanceof Function) { return false }
  if (Array.isArray(x) && Array.isArray(y)) { return x.length === y.length && x.every((v, i) => eq(v, y[i])) }
  if (Object(x) === x && Object(y) === y) { return eq(Object.entries(x).sort(compareKey), Object.entries(y).sort(compareKey)) }
  return false;
};

const compareKey = ([lhs],[rhs]) => lhs.localeCompare(rhs);

const asserteq = (e, r) => console.assert(eq(e, r), `expected: ${e}, result: ${r}`);

----------------------------------------------------------------------------------------------------
const memoize = (m, f) => (...xs) => m.get(xs) ?? m.set(f(...xs), xs);

const map = (ind) => {
  const m = new Map();
  return { get: (xs) => m.get(ind(...xs)), set: (r, xs) => (m.set(ind(...xs), r), r) };
};
const array = (n, ind) => {
  const m = Array(n);
  return { get: (xs) => m[ind(...xs)], set: (r, xs) => (m[ind(...xs)] = r, r) };
};

const ind = (...ns) => (...xs) => xs.reduceRight(([r, b], x, i) => [r + x * b, b * ns[i]], [0, 1])[0];

----------------------------------------------------------------------------------------------------
const subseqs = (xs) => {
  if (xs.length === 0) { return [] }
  if (xs.length === 1) { return [[xs[0]]] }
  const ys = xs.slice(0, -1), x = xs[xs.length - 1];
  const zs = subseqs(ys);
  return [...zs, [x], ...zs.map(z => [...z, x])];
};

f {} -> {}
f {x} -> { {x} }
f {Y|x} -> f Y + { Z+x, Z <- {} + f Y }

----------------------------------------------------------------------------------------------------
const noop = () => undefined;
const log = console.log.bind(console);
const logn = ({ n = 30, log }) => (...xs) => { if (n-- <= 0) { process.exit() }; log(...xs) };

const make_logf = ({ log, ys, yp, n = 0, d = '.' }) => (p = '') => (f) => (...xs) => {
  if (ys) { log(d.repeat(n - 1) + yp, ...ys, ':') }
  ys = xs, yp = p;
  ++n; 
  
  const r = f && f(...xs);
  
  --n;
  log(...(ys ? [d.repeat(n) + yp, ...ys] : [d.repeat(n)]), ...(f ? ['->', r] : []));
  ys = yp = undefined;

  return r;
};

const logf = make_logf({ log });

....................................................................................................
const foo = logf('foo')((m, n) => {
  const dbg = logf('dbg')();

  const iter = logf('iter')((i, j) => { ... dbg(...); ... });

  // const dp = iter;
  const dp = memoize(array((i, j) => (i * n) + j), iter);
  
  return dp(0, 0);
});
